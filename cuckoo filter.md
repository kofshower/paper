---


---

<h1 id="cuckoo-filter-practically-better-than-bloom">Cuckoo Filter: Practically Better Than Bloom</h1>
<h2 id="abstract">ABSTRACT</h2>
<p>In many networking systems, Bloom filters are used for highspeed set membership tests. They permit a small fraction of false positive answers with very good space efficiency. However, they do not permit deletion of items from the set, and previous attempts to extend “standard” Bloom filters to support deletion all degrade either space or performance. We propose a new data structure called the cuckoo filter that can replace Bloom filters for approximate set membership tests. Cuckoo filters support adding and removing items dynamically while achieving even higher performance than Bloom filters. For applications that store many items and target moderately low false positive rates, cuckoo filters have lower space overhead than space<br>
optimized Bloom filters. Our experimental results also show that cuckoo filters outperform previous data structures that extend Bloom filters to support deletions substantially in both time and space.在许多网络系统中，Bloom过滤器用于高速集合成员测试。 它们允许一小部分假阳性答案，具有非常好的空间效率。 但是，它们不允许从集合中删除项目，之前尝试扩展“标准”Bloom过滤器以支持删除都会降低空间或性能。 我们提出了一种名为cuckoo过滤器的新数据结构，它可以取代Bloom过滤器进行近似集合成员资格测试。 Cuckoo过滤器支持动态添加和删除项目，同时实现比Bloom过滤器更高的性能。 对于存储许多项目并且针对中度低误报率的应用程序，布谷鸟过滤器比空间优化的布隆过滤器具有更低的空间开销。 我们的实验结果还表明，布谷鸟过滤器优于以前的数据结构，这些数据结构扩展了Bloom过滤器以支持基本上在时间和空间上的删除。</p>
<h2 id="introduction">INTRODUCTION</h2>
<p>Many databases, caches, routers, and storage systems use approximate set membership tests to decide if a given item is in a (usually large) set, with some small false positive probability. The most widely-used data structure for this test is the Bloom filter [3], which has been studied extensively due to its memory efficiency. Bloom filters have been used to: reduce the space required in probabilistic routing tables [25]; speed longest-prefix matching for IP addresses [9]; improve network state management and monitoring [24, 4]; and encode multicast forwarding information in packets [15], among many other applications [6].许多数据库，高速缓存，路由器和存储系统使用近似集合成员资格测试来确定给定项目是否在（通常是大的）集合中，具有一些小的误报概率。 该测试最广泛使用的数据结构是Bloom过滤器[3]，由于其内存效率，已对其进行了广泛的研究。 布隆过滤器已用于：减少概率路由表中所需的空间[25]; 速度最长前缀匹配IP地址[9]; 改善网络状态管理和监控[24,4]; 在许多其他应用程序[6]中编码数据包[15]中的多播转发信息。<br>
A limitation of standard Bloom filters is that one cannot remove existing items without rebuilding the entire filter (or possibly introducing generally less desirable false negatives). Several approaches extend standard Bloom filters to support deletion, but with significant space or performance overhead. Counting Bloom filters [12] have been suggested for multiple applications [24, 25, 9], but they generally use 3–4× space to retain the same false positive rate as a space-optimized Bloom filter. Other variants include d-left counting Bloom filters [5], which are still 1.5× larger, and quotient filters [2], which provide significantly degraded lookup performance to yield comparable space overhead to Bloom filters. This paper shows that supporting deletion in approximate set membership tests need not impose higher overhead in space or performance compared to standard Bloom filters. We propose the cuckoo filter, a practical data structure that provides four major advantages. 标准布隆过滤器的限制是，如果不重建整个过滤器（或者可能引入通常不太理想的假阴性），则无法移除现有项目。 有几种方法可以扩展标准Bloom过滤器以支持删除，但会占用大量空间或性能开销。 计数Bloom过滤器[12]已被建议用于多种应用[24,25,9]，但它们通常使用3-4×空间来保持与空间优化布隆过滤器相同的误报率。 其他变体包括d-left计数Bloom过滤器[5]，它们仍然是1.5倍大，而商滤波器[2]，它们提供显着降低的查找性能，以产生与Bloom过滤器相当的空间开销。 本文表明，与标准布隆过滤器相比，在近似集合成员测试中支持删除不需要在空间或性能上施加更高的开销。 我们提出了布谷鸟过滤器，这是一种实用的数据结构，具有四大优势。</p>
<ul>
<li>It supports adding and removing items dynamically;</li>
<li>It provides higher lookup performance than traditional Bloom filters, even when close to full (e.g., 95% space utilized);</li>
<li>It is easier to implement than alternatives such as the quotient filter;</li>
<li>It uses less space than Bloom filters in many practical applications, if the target false positive rate <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span> is less than 3%.<br>
1.它支持动态添加和删除项目;<br>
2.它提供比传统布隆过滤器更高的查找性能，即使接近满（例如，使用95％的空间）;<br>
3.它比诸如商滤波器之类的替代方案更容易实现;<br>
4.如果目标误报率<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>小于3％，它在许多实际应用中使用比Bloom过滤器更少的空间。<br>
A cuckoo filter is a compact variant of a cuckoo hash table [21] that stores only fingerprints—a bit string derived from the item using a hash function—for each item inserted, instead of key-value pairs. The filter is densely filled with fingerprints (e.g., 95% entries occupied), which confers high space efficiency. A set membership query for item x simply searches the hash table for the fingerprint of x, and returns true if an identical fingerprint is found.布谷鸟过滤器是布谷鸟哈希表[21]的紧凑变体，它仅存储指纹 - 使用散列函数从项目派生的位串 - 用于插入的每个项目，而不是键值对。 过滤器密集地填充指纹（例如占据95％的条目），这提供了高空间效率。 项x的集合成员资格查询只是在哈希表中搜索x的指纹，如果找到相同的指纹则返回true。<br>
When constructing a cuckoo filter, its fingerprint size is determined by the target false positive rate <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>. Smaller values of <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span> require longer fingerprints to reject more false queries. Interestingly, while we show that cuckoo filters are practically better than Bloom filters for many real workloads, they are asymptotically worse: the minimum fingerprint size used in the cuckoo filter grows logarithmically with the number of entries in the table (as we explain in Section 4). As a consequence, the per-item space overhead is higher for larger tables, but this use of extra space confers a lower false positive rate. For practical problems with a few billion items or fewer,a cuckoo filter uses less space while supporting deletion than a non-deletable, space-optimized Bloom filter when <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span> &lt; 3%.构建布谷鸟过滤器时，其指纹大小由目标误报率<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>确定。较小的<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>值需要较长的指纹来拒绝更多的错误查询。 有趣的是，虽然我们表明杜鹃过滤器实际上比Bloom过滤器更适用于许多实际工作负载，但它们渐渐变差：布谷鸟过滤器中使用的最小指纹大小与表中的条目数呈对数增长（正如我们在第4节中解释的那样））。 因此，对于较大的表，每个项目的空间开销较高，但是这种额外空间的使用赋予较低的误报率。 对于具有几十亿或更少项目的实际问题，当<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span> &lt;3％时，布谷鸟过滤器在支持删除时使用的空间少于不可删除的，空间优化的布隆过滤器。<br>
Cuckoo filters are substantially different from regular hash tables because only fingerprints are stored in the filter and the original key and value bits of each item are no longer retrievable. Because full keys are not stored, a cuckoo filter cannot even perform standard cuckoo hashing to insert new items, which involves moving existing keys based on their hash values. This difference means that the standard techniques, analyses, and optimizations that apply to cuckoo hashing do not necessarily carry over to cuckoo filters.Cuckoo过滤器与常规散列表有很大不同，因为只有指纹存储在过滤器中，并且每个项目的原始键和值位不再可检索。 由于未存储完整密钥，因此布谷鸟过滤器甚至无法执行标准布谷鸟散列来插入新项目，这涉及根据哈希值移动现有密钥。 这种差异意味着适用于布谷鸟哈希的标准技术，分析和优化不一定会延续到布谷鸟过滤器。<br>
<strong>Technical contributions</strong> made by this paper include<br>
• Applying partial-key cuckoo hashing—a variant of standard cuckoo hashing—to build cuckoo filters that support dynamic addition and deletion of items (Section 3).<br>
• Exploring the reason why partial-key cuckoo hashing ensures high table occupancy for most real-world applications (Section 4).<br>
• Optimizing cuckoo filters to outperform Bloom filters in space efficiency (Section 5).<br>
本文的技术贡献包括<br>
•应用部分密钥布谷鸟散列 - 标准布谷鸟散列的变体 - 来构建支持动态添加和删除项目的布谷鸟过滤器（第3节）。<br>
•探索部分密钥布谷鸟哈希的原因，以确保大多数实际应用程序的高表占用率（第4节）。<br>
•优化布谷鸟过滤器，在空间效率方面优于布鲁姆过滤器（第5节）。</li>
</ul>
<h2 id="background-and-related-work">BACKGROUND AND RELATED WORK</h2>
<h3 id="bloom-filters-and-variants">Bloom Filters and Variants</h3>
<p>We compare standard Bloom filters and the variants that include support for deletion or better lookup performance, as summarized in Table 1. These data structures are evaluated empirically in Section 7. Cuckoo filters achieve higher space efficiency and performance than these data structures. Standard Bloom filters [3] provide a compact representation of a set of items that supports two operations: Insert and Lookup. 我们比较标准Bloom过滤器和包含删除支持或更好的查找性能的变体，如表1所示。这些数据结构在第7节中根据经验进行评估.Cuckoo过滤器比这些数据结构实现更高的空间效率和性能。 标准布隆过滤器[3]提供了一组项的紧凑表示，它支持两种操作：插入和查找。<br>
A Bloom filter allows a tunable false positive rate <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span> so that a query returns either “definitely not” (with no error), or “probably yes” (with probability <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span> of being wrong). The lower <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span> is, the more space the filter requires. A Bloom filter consists of k hash functions and a bit array with all bits initially set to “0”. To insert an item, it hashes this item to k positions in the bit array by k hash functions, and then sets all k bits to “1”. Lookup is processed similarly, except it reads k corresponding bits in the array: if all the bits are set, the query returns true; otherwise it returns false.Bloom filters do not support deletion.Bloom过滤器允许可调误差率<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>，以便查询返回“绝对不”（没有错误）或“可能是”（概率<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>为错误）。 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>越低，滤波器所需的空间越大。 Bloom过滤器由k个散列函数和一个位数组组成，所有位最初都设置为“0”。 为了插入一个项目，它通过k个散列函数将该项目散列到位数组中的k个位置，然后将所有k个位设置为“1”。 类似地处理查找，除了它读取数组中的k个相应位：如果所有位都已设置，则查询返回true; 否则返回false.Bloom过滤器不支持删除。<br>
Bloom filters can be very space-efficient, but are not optimal [20]. For a false positive rate <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>, a space-optimized Bloom filter uses <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ϵ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">k = log2 (1/\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">ϵ</span><span class="mclose">)</span></span></span></span></span> hash functions. Such a Bloom filter can store each item using <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.44</mn><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ϵ</mi><mo>)</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1.44 log2 (1/\epsilon) bits</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">4</span><span class="mord">4</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">ϵ</span><span class="mclose">)</span><span class="mord mathit">b</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">s</span></span></span></span></span>, which depends only on <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span> rather than the item size or the total number of items. The information-theoretic minimum requires <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ϵ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">log2 (1/\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">ϵ</span><span class="mclose">)</span></span></span></span></span> bits per item, so a space-optimized Bloom filter imposes a 44% space overhead over the information-theoretic lower bound.布隆过滤器可以非常节省空间，但不是最佳的[20]。 对于误报率<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>，空间优化的布隆过滤器使用<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ϵ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">k = log2 (1/\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">ϵ</span><span class="mclose">)</span></span></span></span></span>散列函数。 这样的布隆过滤器可以使用<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.44</mn><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ϵ</mi><mo>)</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">1.44 log2 (1/\epsilon) bits</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">4</span><span class="mord">4</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">ϵ</span><span class="mclose">)</span><span class="mord mathit">b</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit">s</span></span></span></span></span>位来存储每个项目，这仅取决于<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>而不是项目大小或项目总数。 信息理论最小值要求每项<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ϵ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">log2 (1/\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">ϵ</span><span class="mclose">)</span></span></span></span></span>位，因此空间优化的Bloom过滤器在信息理论下限上占据44％的空间开销。<br>
The information theoretic optimum is essentially achievable for a static set by using fingerprints (of length <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ϵ</mi><mo>⌉</mo></mrow><annotation encoding="application/x-tex">\lceil 1/\epsilon \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌈</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">ϵ</span><span class="mclose">⌉</span></span></span></span></span> bits) and a perfect hash table [6]. To efficiently handle deletions, we replace a perfect hash function with a well-designed cuckoo hash table.通过使用指纹（长度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌈</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ϵ</mi><mo>⌉</mo></mrow><annotation encoding="application/x-tex">\lceil 1/\epsilon \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌈</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">ϵ</span><span class="mclose">⌉</span></span></span></span></span>位）和完美的哈希表[6]，静态集合基本上可以实现信息理论最优。 为了有效地处理删除，我们用精心设计的cuckoo哈希表替换完美的哈希函数。<br>
<strong>Counting Bloom filters</strong> [12] extend Bloom filters to allow deletions. A counting Bloom filter uses an array of counters in place of an array of bits. An insert increments the value of k counters instead of simply setting k bits, and a lookup checks if each of the required counters is non-zero. The delete operation decrements the values of these k counters. To prevent arithmetic overflow (i.e., incrementing a counter that has the maximum possible value), each counter in the array must be sufficiently large in order to retain the Bloom filter’s properties. In practice, the counter consists of four or more bits, and a counting Bloom filter therefore requires 4× more space than a standard Bloom filter. (One can construct counting Bloom filters to use less space by introducing a secondary hash table structure to manage overflowing counters, at the expense of additional complexity.)Counting Bloom过滤器[12]扩展Bloom过滤器以允许删除。 计数Bloom过滤器使用计数器数组代替位数组。 插入增加k计数器的值而不是简单地设置k位，并且查找检查每个所需的计数器是否为非零。 删除操作会减少这些k计数器的值。 为了防止算术溢出（即，递增具有最大可能值的计数器），阵列中的每个计数器必须足够大，以便保留布隆过滤器的属性。 实际上，计数器由四位或更多位组成，因此计数布隆过滤器需要比标准布隆过滤器多4倍的空间。 （通过引入辅助哈希表结构来管理溢出计数器，可以构建计数Bloom过滤器以减少使用空间，但代价是额外的复杂性。）<br>
<strong>Blocked Bloom filters</strong> [22] do not support deletion, but provide better spatial locality on lookups. A blocked Bloom filter consists of an array of small Bloom filters, each fitting in one CPU cache line. Each item is stored in only one of these small Bloom filters determined by hash partitioning. As a result, every query causes at most one cache miss to load that Bloom filter, which significantly improves performance. A drawback is that the false positive rate becomes higher because of the imbalanced load across the array of small Bloom filters.Blocked Bloom过滤器[22]不支持删除，但在查找时提供更好的空间局部性。 被阻塞的Bloom过滤器由一系列小Bloom过滤器组成，每个过滤器都适合一个CPU高速缓存行。 每个项目仅存储在由散列分区确定的这些小Bloom过滤器中的一个中。 因此，每个查询都会导致最多一次缓存未命中加载Bloom过滤器，从而显着提高性能。 缺点是由于小Bloom滤波器阵列上的负载不平衡，误报率变得更高。<br>
<strong>d-left Counting Bloom filters</strong> [5] are similar to the approach we use here. Hash tables using d-left hashing [19] store fingerprints for stored items. These filters delete items by removing their fingerprint. Compared to counting Bloom filters, they reduce the space cost by 50%, usually requiring 1.5 − 2× the space compared to a space-optimized non-deletable Bloom filter. Cuckoo filters achieve better space efficiency than d-left counting Bloom filters as we show, and have other advantages, including simplicity.d-left Counting Bloom过滤器[5]类似于我们在这里使用的方法。 使用d-left散列[19]的散列表存储存储项目的指纹。 这些过滤器通过删除指纹来删除项目。 与计算布隆过滤器相比，它们将空间成本降低了50％，与空间优化的不可删除布隆过滤器相比，通常需要1.5  -  2倍的空间。 与我们展示的d-left计数Bloom过滤器相比，咕咕过滤器实现了更好的空间效率，并具有其他优点，包括简单性。<br>
<strong>Quotient filters</strong> [2] are also compact hash tables that store fingerprints to support deletion. Quotient filters uses a technique similar to linear probing to locate a fingerprint, and thus provide better spatial locality. However, they require additional meta-data to encode each entry, which requires 10 ∼ 25% more space than a comparable standard Bloom filter. Moreover, all of its operations must decode a sequence of table entries before reaching the target item, and the more the hash table is filled, the longer these sequences become. As a result, its performance drops significantly when the occupancy of the hash table exceeds 75%.商数过滤器[2]也是紧凑的哈希表，用于存储指纹以支持删除。 商数过滤器使用类似于线性探测的技术来定位指纹，从而提供更好的空间局部性。 但是，它们需要额外的元数据来编码每个条目，这比同等的标准布隆过滤器需要多10~25％的空间。 此外，它的所有操作必须在到达目标项之前解码一系列表条目，并且填充的哈希表越多，这些序列变得越长。 结果，当哈希表的占用率超过75％时，其性能显着下降。<br>
<strong>Other Variants</strong>: Other variants have been proposed to improve Bloom filters, either in space and/or performance. RankIndexed Hashing [14] builds linear chaining hash tables to store compressed fingerprints. Although similar to and somewhat more space efficient than d-left counting Bloom filters, updating the internal index that reduces the chaining cost is very expensive, making it less appealing in dynamic settings. Putze et al. proposed two variants of Bloom filters [22]. One is the previously discussed Blocked Bloom filter; the other, called a Golomb-Compressed Sequence stores all items’ fingerprints in a sorted list. Its space is near-optimal, but the data structure is static and requires non-constant lookup time to decode the encoded sequence. It is therefore not evaluated with other filters in this paper. Pagh et al. proposed an asymptotically space-optimal data structure [20] based on Cleary [8]. This data structure, however, is substantially more complex than its alternatives and does not appear amenable to a high performance implementation. In contrast, cuckoo filters are easy to implement.其他变体：已经提出了其他变体来改进布鲁姆滤波器，无论是空间和/或性能。 RankIndexed Hashing [14]构建线性链接哈希表来存储压缩指纹。尽管与d-left计数布隆过滤器相似且更节省空间，但更新降低链接成本的内部索引非常昂贵，使其在动态设置中不那么吸引人。 Putze等人。提出了Bloom过滤器的两种变体[22]。一个是先前讨论的Blocked Bloom过滤器;另一个称为Golomb压缩序列的所有项目的指纹都存储在排序列表中。它的空间接近最佳，但数据结构是静态的，需要非恒定的查找时间来解码编码序列。因此，本文未对其他过滤器进行评估。 Pagh等人。提出了一种基于Cleary [8]的渐近空间最优数据结构[20]。然而，这种数据结构比其替代方案复杂得多，并且似乎不适合高性能实现。相比之下，布谷鸟过滤器易于实施。</p>
<h3 id="cuckoo-hash-tables">Cuckoo Hash Tables</h3>
<p><strong>Cuckoo Hashing Basics</strong>: A basic cuckoo hash table [21] consists of an array of buckets where each item has two candidate buckets determined by hash functions h1(x) and h2(x). The lookup procedure checks both buckets to see if either contains this item. Figure 1(a) shows the example of inserting a new item x in to a hash table of 8 buckets, where x can be placed in either buckets 2 or 6. If either of x’s two buckets is empty, the algorithm inserts x to that free bucket and the insertion completes. If neither bucket has space, as is the case in this example, the item selects one of the candidate buckets (e.g., bucket 6), kicks out the existing item (in this case “a”) and re-inserts this victim item to its own alternate location. In our example, displacing “a” triggers another relocation that kicks existing item “c” from bucket 4 to bucket 1. This procedure may repeat until a vacant bucket is found as illustrated in Figure 1(b), or until a maximum number of displacements is reached (e.g., 500 times in our implementation). If no vacant bucket is found, this hash table is considered too full to insert. Although cuckoo hashing may execute a sequence of displacements, its amortized insertion time is O(1).<br>
Cuckoo hashing ensures high space occupancy because it refines earlier item-placement decisions when inserting new items. Most practical implementations of cuckoo hashing extend the basic description above by using buckets that hold multiple items, as suggested in [10]. The maximum possible load when using k hash functions and buckets of size b assuming all hash functions are perfectly random has been analyzed [13]. With proper configuration of cuckoo hash table parameters (explored in Section 5), the table space can be 95% filled with high probability.杜鹃哈希基础：基本的布谷鸟哈希表[21]由一系列桶组成，其中每个项目都有两个由哈希函数h1（x）和h2（x）确定的候选桶。查找过程检查两个存储桶以查看是否包含此项。图1（a）显示了将新项x插入到8个桶的哈希表中的示例，其中x可以放在桶2或6中。如果x的两个桶中的任何一个为空，则算法将x插入到免费桶和插入完成。如果两个桶都没有空间（如本示例中的情况），则该项目选择一个候选桶（例如，桶6），踢出现有项（在这种情况下为“a”）并重新插入该受害者项目以它自己的替代位置。在我们的示例中，替换“a”触发另一个重新定位，将现有项“c”从桶4踢到桶1.此过程可以重复，直到找到空桶，如图1（b）所示，或直到最大数量为达到了位移（例如，在我们的实施中达到500次）。如果未找到空闲存储桶，则认为此哈希表太满而无法插入。虽然布谷鸟散列可能会执行一系列位移，但其分摊的插入时间为O（1）。<br>
杜鹃散列确保了高空间占用率，因为它在插入新项目时改进了早期的项目放置决策。杜鹃散列的大多数实际实现通过使用包含多个项的桶来扩展上面的基本描述，如[10]中所建议的。假设所有散列函数都是完全随机的，使用k散列函数和大小为b的桶的最大可能负载已被分析[13]。通过正确配置cuckoo哈希表参数（在第5节中探讨），表空间可以高概率地填充95％。<br>
<strong>Using Cuckoo Hashing for Set-membership</strong>: Recently, standard cuckoo hash tables have been used to provide set membership information in a few applications. To support transactional memory, Sanchez et al. proposed to store the read/write set of memory addresses of each transaction in a cuckoo hash table, and to convert this table to Bloom filters when full [23]. Their design used standard cuckoo hash tables, and thus required much more space than cuckoo filters. Our previous study in building high-speed and memoryefficient key-value stores [17, 11] and software-based Ethernet switches [26] all applied cuckoo hash tables as internal data structures. That work was motivated by and also focused on improving hash table performance by an optimization called partial-key cuckoo hashing. However, as we show in this paper, this technique also enabled a new approach to build a Bloom filter replacement which has not been studied before. As a result, this paper also applies partial-key cuckoo hashing, but more importantly it offers an in-depth analysis of using this technique specifically to serve set membership tests (rather than key-value queries) and further compares the performance of cuckoo filters with alternative set membership data structures.使用Cuckoo Hashing进行集合成员资格：最近，标准的cuckoo散列表已被用于在一些应用程序中提供集合成员资格信息。为了支持事务记忆，Sanchez等人。建议在cuckoo哈希表中存储每个事务的读/写内存地址集，并在满时将该表转换为Bloom过滤器[23]。他们的设计使用标准的布谷鸟哈希表，因此比布谷鸟过滤器需要更多的空间。我们之前关于构建高速和内存效率高的键值存储[17,11]和基于软件的以太网交换机[26]的研究都将布谷鸟哈希表应用为内部数据结构。这项工作的动机是通过称为部分密钥布谷鸟哈希的优化来改进哈希表的性能。然而，正如我们在本文中所展示的，这种技术还使得能够构建Bloom过滤器替换的新方法尚未被研究过。因此，本文还应用了部分密钥布谷鸟哈希，但更重要的是，它提供了深入分析，使用这种技术专门用于集合成员资格测试（而不是键值查询），并进一步比较布谷鸟过滤器的性能使用备用集成员资格数据结构。<br>
<strong>Challenges in Cuckoo Filter</strong>: To make cuckoo filters highly space efficient, we use a multi-way associative cuckoo hash table to provide high-speed lookup and high table occupancy (e.g., 95% hash table slots filled); to further reduce the hash table size, each item is first hashed into a constant-sized fingerprint before inserted into this hash table. The challenge of applying this data structure is to redesign the insert process and carefully configure the hash table to minimize space usage per item:<br>
Cuckoo过滤器面临的挑战：为了使布谷鸟过滤器具有高效空间，我们使用多路关联布谷鸟哈希表来提供高速查找和高表占用率（例如，填充95％的哈希表槽）; 为了进一步减少散列表大小，在插入此散列表之前，首先将每个项目散列为一个恒定大小的指纹。 应用此数据结构的挑战是重新设计插入过程并仔细配置哈希表以最小化每个项目的空间使用：</p>
<ul>
<li>First, storing only fingerprints in the hash table prevents inserting items using the standard cuckoo hashing approach. Because in cuckoo hashing the insertion algorithm must be able to relocate existing fingerprints to their alternative locations. A space-inefficient but straightforward solution is to store each inserted item in its entirety (perhaps externally to the table); given the original item (“key”), calculating its alternate location is easy. In contrast, cuckoo filters use partial-key cuckoo hashing to find an item’s alternate location based on only its fingerprint (Section 3).首先，仅在哈希表中存储指纹可防止使用标准布谷鸟哈希方法插入项目。 因为在布谷鸟哈希中，插入算法必须能够将现有指纹重新定位到其替代位置。 空间效率低但直接的解决方案是将每个插入的项目全部存储（可能在表格外部）; 给定原始项目（“密钥”），计算其备用位置很容易。 相比之下，布谷鸟过滤器使用部分密钥布谷鸟哈希来仅根据其指纹找到项目的备用位置（第3节）。</li>
<li>Second, cuckoo filter associates each item with multiple possible locations in the hash table. This flexibility in where to store an item improves table occupancy, but retaining the same false positive rate when probing more possible locations on each lookup requires more space for longer fingerprints. In Section 5, we present our analysis to optimize the balance between the table occupancy and its size to minimize the average space cost per item.其次，布谷鸟过滤器将每个项目与哈希表中的多个可能位置相关联。 这种存储项目的灵活性提高了表的占用率，但是当在每次查找中探测更多可能的位置时保持相同的误报率需要更多空间以用于更长的指纹。 在第5节中，我们提出了分析，以优化表占用率与其大小之间的平衡，以最小化每个项目的平均空间成本。</li>
</ul>
<h3 id="cuckoo-filter-algorithms">CUCKOO FILTER ALGORITHMS</h3>
<p>In this paper, the basic unit of the cuckoo hash tables used for our cuckoo filters is called an entry. Each entry stores one fingerprint. The hash table consists of an array of buckets, where a bucket can have multiple entries.在本文中，用于我们的布谷鸟过滤器的布谷鸟哈希表的基本单位称为条目。 每个条目存储一个指纹。 哈希表由一系列桶组成，其中桶可以有多个条目。<br>
This section describes how cuckoo filters perform Insert, Lookup and Delete operations. Section 3.1 presents partial-key cuckoo hashing, a variant of standard cuckoo hashing that enables cuckoo filters to insert new items dynamically. This technique was first introduced in previous work [11], but there the context was improving the lookup and insert performance of regular cuckoo hash tables where full keys were stored. In contrast, this paper focuses on optimizing and analyzing the space efficiency when using partial-key cuckoo hashing with only fingerprints, to make cuckoo filters competitive with or even more compact than Bloom filters.本节介绍布谷鸟过滤器如何执行插入，查找和删除操作。 3.1节介绍了部分密钥布谷鸟哈希，这是一种标准布谷鸟哈希变种，可以让布谷鸟过滤器动态插入新项目。 这种技术最初是在以前的工作中引入的[11]，但是上下文改进了常规cuckoo哈希表的查找和插入性能，其中存储了完整的密钥。 相比之下，本文着重于优化和分析空间效率，当使用只有指纹的部分键布谷鸟哈希时，使布谷鸟过滤器比布鲁姆过滤器更具竞争力或甚至更紧凑。<br>
<img src="https://lh3.googleusercontent.com/wMjIZnhSDHj8_2mtpwsFy1gtPcltoTwYmsyr5haxt0wBYzjw90yBD40_5XYTGFUbSP0AJCFr9YoV" alt="enter image description here"></p>
<h4 id="insert">Insert</h4>
<p>As previously stated, with standard cuckoo hashing, inserting new items to an existing hash table requires some means of accessing the original existing items in order to determine where to relocate them if needed to make room for the new ones (Section 2.2). Cuckoo filters, however, only store fingerprints and therefore there is no way to restore and rehash the original keys to find their alternate locations. To overcome this limitation, we utilize a technique called partial-key cuckoo hashing to derive an item’s alternate location based on its fingerprint. For an item x, our hashing scheme calculates the indexes of the two candidate buckets as follows:如前所述，使用标准的布谷鸟哈希，将新项目插入现有哈希表需要一些方法来访问原始现有项目，以便确定在需要时重新定位它们的位置以便为新项目腾出空间（第2.2节）。 但是，布谷鸟过滤器只存储指纹，因此无法恢复和重新散列原始密钥以查找其备用位置。 为了克服这个限制，我们利用一种称为部分密钥布谷鸟哈希的技术，根据其指纹导出项目的备用位置。 对于项目x，我们的哈希方案计算两个候选桶的索引，如下所示：</p>
<blockquote>
<p>h1(x) = hash(x),<br>
h2(x) = h1(x) ⊕ hash(x’s fingerprint).</p>
</blockquote>
<p>The xor operation in Eq. (1) ensures an important property: h1(x) can also be calculated from h2(x) and the fingerprint using the same formula. In other words, to displace a key originally in bucket i (no matter if i is h1(x) or h2(x)), we directly calculate its alternate bucket j from the current bucket index i and the fingerprint stored in this bucket by 方程式中的xor运算 （1）确保一个重要的属性：h1（x）也可以从h2（x）和指纹使用相同的公式计算。 换句话说，为了替换最初在桶i中的密钥（无论我是h1（x）还是h2（x）），我们直接从当前桶索引i和存储在该桶中的指纹计算其备用桶j</p>
<blockquote>
<p>j = i ⊕ hash(fingerprint).</p>
</blockquote>
<p>Hence, an insertion only uses information in the table, and never has to retrieve the original item x.因此，插入仅使用表中的信息，而不必检索原始项x。<br>
In addition, the fingerprint is hashed before it is xor-ed with the index of its current bucket to help distribute the items uniformly in the table. If the alternate location were calculated by “i⊕fingerprint” without hashing the fingerprint, the items kicked out from nearby buckets would land close to each other in the table, if the size of the fingerprint is small compared to the table size. For example, using 8-bit fingerprints the items kicked out from bucket i will be placed to buckets that are at most 256 buckets away from bucket i, because the xor operation would alter the eight low order bits of the bucket index while the higher order bits would not change. Hashing the fingerprints ensures that these items can be relocated to buckets in an entirely different part of the hash table, hence reducing hash collisions and improving the table utilization.此外，指纹在与其当前存储桶的索引进行xor-ed之前进行哈希处理，以帮助在表中统一分配项目。 如果通过“i⊕fingerprint”计算备用位置而不对指纹进行散列，则如果指纹的大小与表格大小相比较小，则从附近的桶中踢出的项目将在表格中彼此靠近。 例如，使用8位指纹，从桶i中踢出的项目将被放置到距离桶i最多256个桶的桶中，因为xor操作将改变桶索引的8个低位比特而更高的顺序 比特不会改变。 散列指纹可确保这些项目可以在散列表的完全不同的部分重新定位到存储桶，从而减少散列冲突并提高表利用率。<br>
Using partial-key cuckoo hashing, cuckoo filters add new items dynamically by the process shown in Algorithm 1. Because these fingerprints can be significantly shorter than the size of h1 or h2, there are two consequences. First, the total number of different possible choices of (h1, h2) as calculated by Eq. (1) can be much smaller than using a perfect hash to derive h1 and h2 as in standard cuckoo hashing. This may cause more collisions, and in particular previous analyses for cuckoo hashing (as in [10, 13]) do not hold. A full analysis of partial-key cuckoo hashing remains open (and beyond this paper); in Section 4, we provide a detailed discussion of this issue and consider how to achieve high occupancy for practical workloads.使用部分密钥布谷鸟哈希，布谷鸟过滤器通过算法1中显示的过程动态地添加新项目。因为这些指纹可能明显短于h1或h2的大小，所以有两个后果。 首先，由等式1计算的（h1，h2）的不同可能选择的总数。 （1）可以比使用完美哈希导出h1和h2小得多，就像在标准的布谷鸟哈希中一样。 这可能会导致更多的冲突，特别是之前对布谷鸟哈希的分析（如[10,13]中所述）不成立。 部分密钥杜鹃哈希的完整分析仍然存在（超出本文）; 在第4节中，我们提供了有关此问题的详细讨论，并考虑如何实现实际工作负载的高占用率。<br>
Second, inserting two different items x and y that have the same fingerprint is fine; it is possible to have the same fingerprint appear multiple times in a bucket. However, cuckoo filters are not suitable for applications that insert the same item more than 2b times (b is the bucket size), because the two buckets for this duplicated item will become overloaded. There are several solutions for such a scenario. First, if the table need not support deletion, then this issue does not arise, because only one copy of each fingerprint must be stored. Second, one could, at some space cost, associate counters with buckets, and increment/decrement them appropriately. Finally, if the original keys are stored somewhere (perhaps in slower external storage), one could consult that record to prevent duplicate insertion entirely, at the cost of slowing down insertion if the table already contains a (false positive) matching entry for the bucket and fingerprint. Similar requirements apply to traditional and d-left counting Bloom filters.其次，插入具有相同指纹的两个不同的项目x和y是好的;可以在桶中多次出现相同的指纹。但是，布谷鸟过滤器不适用于插入相同项目超过2b次的应用程序（b是桶大小），因为此重复项目的两个存储桶将变得过载。这种情况有几种解决方案。首先，如果表不需要支持删除，则不会出现此问题，因为每个指纹只能存储一个副本。其次，可以在一些空间成本下将计数器与桶相关联，并适当地增加/减少它们。最后，如果原始密钥存储在某处（可能在较慢的外部存储器中），则可以查询该记录以防止完全重复插入，如果表已经包含用于存储桶的（误报）匹配条目，则以降低插入速度为代价和指纹。类似的要求适用于传统和左计数布隆过滤器。<br>
<img src="https://lh3.googleusercontent.com/RSRaF18yIzPKFg6ehd-ZMAJuBwL_N73_Y2Q_pHPSBe1Jl-ud5JeZ06hrVY6khLWqosSsv9TT3GiM" alt="enter image description here"></p>
<h4 id="lookup">Lookup</h4>
<p>The lookup process of a cuckoo filter is simple, as shown in Algorithm 2. Given an item x, the algorithm first calculates x’s fingerprint and two candidate buckets according to Eq. (1). Then these two buckets are read: if any existing fingerprint in either bucket matches, the cuckoo filter returns true, otherwise the filter returns false. Notice that this ensures no false negatives as long as bucket overflow never occurs.布谷鸟过滤器的查找过程很简单，如算法2所示。给定项目x，算法首先根据等式计算x的指纹和两个候选桶。（1）。 然后读取这两个桶：如果任一桶中的任何现有指纹匹配，则布谷鸟过滤器返回true，否则过滤器返回false。 请注意，只要不会发生存储桶溢出，这就可以确保不会出现错误否定。<br>
<img src="https://lh3.googleusercontent.com/inQYHEvwArFJ0TO4_1lQvrSOwr4J7NR06_EFH-z4-mvcl3z-Vo9br9GojyVB1VBgWz-kNUssoDW6" alt="enter image description here"></p>
<h4 id="delete">Delete</h4>
<p>Standard Bloom filters cannot delete, thus removing a single item requires rebuilding the entire filter, while counting Bloom filters require significantly more space. Cuckoo filters are like counting Bloom filters that can delete inserted items by removing corresponding fingerprints from the hash tables on deletion. Other filters with similar deletion processes prove more complex than cuckoo filters. For example, d-left counting Bloom filters must use extra counters to prevent the “false deletion” problem on fingerprint collision , and quotient filters must shift a sequence of fingerprints to fill the “empty” entry after deletion and maintain their “bucket structure”.标准布隆过滤器无法删除，因此删除单个项目需要重建整个过滤器，而计算布隆过滤器需要更多空间。 Cuckoo过滤器就像计算Bloom过滤器一样，可以通过删除时从哈希表中删除相应的指纹来删除插入的项目。 具有类似删除过程的其他过滤器证明比布谷鸟过滤器更复杂。 例如，d-left计数Bloom过滤器必须使用额外的计数器来防止指纹冲突的“错误删除”问题，商过滤器必须移动一系列指纹以填充删除后的“空”条目并保持其“桶结构”。<br>
The deletion process of cuckoo filters illustrated in Algorithm is much simpler. It checks both candidate buckets for a given item; if any fingerprint matches in any bucket, one copy of that matched fingerprint is removed from that bucket.算法中说明的布谷鸟过滤器的删除过程要简单得多。 它检查给定项目的两个候选桶; 如果任何存储桶中的指纹匹配，则从该存储桶中删除该匹配指纹的一个副本。<br>
Deletion does not have to clean the entry after deleting an item. It also avoids the “false deletion” problem when two items share one candidate bucket and also have the same fingerprint. For example, if both item x and y reside in bucket i1 and collide on fingerprint f , partial-key cuckoo hashing ensures that they both can also reside in bucket i2 because i2 = i1 ⊕ hash(f). When deleting x, it does not matter if the process removes the copy of f added when inserting x or y. After x is deleted, y is still perceived as a set member because there is a corresponding fingerprint left in either bucket i1 and i2. An important consequence of this is that the falsepositive behavior of the filter is unchanged after deletion. (In the above example, y being in the table causes false positives for lookups of x, by definition: they share the same bucket and fingerprint.) This is the expected false-positive behavior of an approximate set membership data structure, and its probability remains bounded by <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>.删除项目后删除不必清除条目。当两个项目共享一个候选桶并且具有相同的指纹时，它还避免了“错误删除”问题。例如，如果项目x和y都位于存储桶i1中并且碰撞在指纹f上，则部分密钥杜鹃散列确保它们都可以驻留在存储桶i2中，因为i2 =i1⊕散列（f）。删除x时，如果进程删除插入x或y时添加的f副本，则无关紧要。在删除x之后，y仍然被视为集合成员，因为在存储桶i1和i2中都存在相应的指纹。这样做的一个重要结果是，删除后过滤器的假阳性行为不变。 （在上面的示例中，表中的y会导致x的查找误报：根据定义：它们共享相同的存储桶和指纹。）这是近似集合成员资格数据结构的预期误报行为及其概率仍受<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span>限制<br>
Note that, to delete an item x safely, it must have been previously inserted. Otherwise, deleting a non-inserted item might unintentionally remove a real, different item that happens to share the same fingerprint. This requirement also holds true for all other deletion-supporting filters.请注意，要安全删除项目x，必须先前已插入。 否则，删除未插入的项目可能会无意中删除碰巧共享相同指纹的真实不同项目。 对于所有其他支持删除的过滤器，此要求也适用。</p>
<blockquote>
<p>A naive implementation of d-left counting Bloom filters has a “false deletion” problem. A d-left counting Bloom filter maps each item to d candidate buckets, each from a partition of the table, and stores the fingerprint in one of its d buckets. If two different items share one and only one bucket, and they have the same fingerprint (which is likely to happen when the fingerprints are small), directly deleting the fingerprint from this specific bucket may cause a wrong item to be removed. To address this issue, d-left counting Bloom filters use an additional counter in each table entry and additional indirections [5].d-left计数Bloom过滤器的简单实现具有“错误删除”问题。 d-left counting布隆过滤器将每个项目映射到d个候选桶，每个桶来自表的分区，并将指纹存储在其d桶中的一个桶中。 如果两个不同的项共享一个且仅一个桶，并且它们具有相同的指纹（当指纹很小时可能发生这种情况），则直接从该特定桶中删除指纹可能导致错误的项被移除。 为了解决这个问题，d-left计数Bloom过滤器在每个表条目中使用一个额外的计数器和额外的间接[5]。<br>
In quotient filters, all fingerprints having the same quotient (i.e., the q most significant bits) must be stored in contiguous entries according to their numerical order. Thus, removing one fingerprint from a cluster of fingerprints must shift all the fingerprints after the hole by one slot, and also modify their meta-data bits [2].在商滤波器中，具有相同商（即，q最高有效位）的所有指纹必须根据它们的数字顺序存储在连续的条目中。 因此，从指纹簇中移除一个指纹必须将孔后的所有指纹移位一个时隙，并且还修改它们的元数据位[2]。<br>
Here we assume hashing the fingerprints (i.e., tx → h(tx)) is collision-free, because in practice tx is a few bits and h(tx) is much longer.这里我们假设散列指纹（即tx→h（tx））是无冲突的，因为实际上tx是几位而h（tx）要长得多。<br>
<img src="https://lh3.googleusercontent.com/aAch5RdcAVmji_cB3B8mzP86EVT6m9VKyBTQcFfgzqKgwGs5L7Voh4mocRJPS0IX0tg72KUBzj4T" alt="enter image description here"></p>
</blockquote>
<h3 id="渐近行为">渐近行为</h3>
<p><img src="https://lh3.googleusercontent.com/9xdR-CKf6Aq7HDSia7bXwiWVLwFQH5L53BXD2GOsboQC9iEtzQA7W3Ll9gZfh9dZhC1FsYOtCiTP" alt="enter image description here"><br>
Here we show that using partial-key cuckoo hashing to store fingerprints in a cuckoo filter to leads to a lower bound on fingerprint sizes that grows slowly with the filter size. This contrasts with other approaches (such as fingerprints and perfect hashing for a static Bloom filter, previously discussed) where the fingerprint size depended only on the desired false positive probability. While this might seem like a negative, in practice the effect seems unimportant. Empirically, a filter containing up to 4 billion items can effectively fill its hash table with loads of 95% when each bucket holds four fingerprints that are 6 bits or larger.在这里，我们展示了使用部分密钥布谷鸟散列来将指纹存储在布谷鸟过滤器中，从而导致指纹大小的下限随着过滤器大小而缓慢增长。 这与其他方法（例如先前讨论的静态布隆过滤器的指纹和完美散列）形成对比，其中指纹大小仅取决于期望的假阳性概率。 虽然这似乎是负面的，但在实践中效果似乎并不重要。 根据经验，当每个桶包含4个6位或更大的指纹时，包含多达40亿个项目的过滤器可以有效地填充其哈希表，其负载为95％。<br>
The notation used for our analysis in this and the next section is: 在本节和下一节中用于分析的符号是：</p>
<blockquote>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathit">ϵ</span></span></span></span></span> target false positive rate<br>
f fingerprint length in bits<br>
α load factor (0 ≤ α ≤ 1)<br>
b number of entries per bucket<br>
m number of buckets<br>
n number of items<br>
C average bits per item</p>
</blockquote>
<p><strong>Minimum Fingerprint Size</strong>: Our proposed partial-key cuckoo hashing derives the alternate bucket of a given item based on its current location and the fingerprint (Section 3). As a result, the candidate buckets for each item are not independent. For example, assume an item can be placed in bucket i1 or i2. According to Eq. (1), the number of possible values of i2 is at most <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>f</mi></msup></mrow><annotation encoding="application/x-tex">2^f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span> when using f-bit fingerprints. Using 1-byte fingerprints, given i1 there are only up to <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>f</mi></msup></mrow><annotation encoding="application/x-tex">2^f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span> = 256 different possible values of i2. For a table of m buckets, when <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>f</mi></msup></mrow><annotation encoding="application/x-tex">2^f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span> &lt; m (or equivalently f &lt; log2 m bits), the choice of i2 is only a subset of all m buckets of the entire hash table.<strong>最小指纹大小</strong>：我们建议的部分密钥杜鹃散列根据其当前位置和指纹推导出给定项目的备用桶（第3节）。 结果，每个项目的候选桶不是独立的。 例如，假设一个项目可以放在桶i1或i2中。 根据Eq.（1），当使用f位指纹时，i2的可能值的数量最多为<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>f</mi></msup></mrow><annotation encoding="application/x-tex">2^f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span>。 使用1字节指纹，给定i1，i2最多只有<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>f</mi></msup></mrow><annotation encoding="application/x-tex">2^f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span> = 256个不同的可能值。 对于m个桶的表，当<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>f</mi></msup></mrow><annotation encoding="application/x-tex">2^f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span> &lt;m（或等效地f &lt;log2 m位）时，i2的选择仅是整个散列表的所有m个桶的子集。<br>
Intuitively, if the fingerprints are sufficiently long, partialkey cuckoo hashing could still be a good approximation to standard cuckoo hashing; however, if the hash table is very large and stores relatively short fingerprints, the chance of insertion failures will increase due to hash collisions, which may reduce the table occupancy. This situation may arise when a cuckoo filter targets a large number of items but only a moderately low false positive rate. In the following, we determine analytically a lower bound of the probability of insertion failure.直观地说，如果指纹足够长，部分键布谷鸟哈希仍然可以很好地接近标准布谷鸟哈希; 但是，如果散列表非常大并且存储相对较短的指纹，则插入失败的可能性将由于散列冲突而增加，这可能会减少表占用率。 当布谷鸟过滤器针对大量物品但只有中等低误报率时，可能会出现这种情况。 在下文中，我们通过分析确定插入失败概率的下限。<br>
Let us first derive the probability that a given set of q items collide in the same two buckets. Assume the first item x has its first bucket i1 and a fingerprint <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">t(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span>. If the other q − 1 items have the same two buckets as this item x, they must have the same fingerprint <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">t(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span>, which occurs with probability <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>f</mi></msup></mrow><annotation encoding="application/x-tex">1/2^f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span> ; and (2) have their first bucket either i1 or i1 ⊕ h(tx), which occurs with probability 2/m. Therefore the probability of such q items sharing the same two buckets is <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mi mathvariant="normal">/</mi><mi>m</mi><mo separator="true">⋅</mo><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>f</mi></msup><msup><mo>)</mo><mrow><mi>q</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(2/m · 1/2^f )^{q−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">/</span><span class="mord mathit">m</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">q</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span> .让我们首先推导出给定的一组q项在相同的两个桶中碰撞的概率。 假设第一个项目x具有其第一个桶i1和一个指纹<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">t(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span>。 如果其他q-1项目具有与此项目x相同的两个桶，则它们必须具有相同的指纹<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">t(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord mathit">x</span><span class="mclose">)</span></span></span></span></span>，其概率为<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>f</mi></msup></mrow><annotation encoding="application/x-tex">1/2^f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span></span></span></span></span>; （2）使它们的第一个桶为i1或i1⊕h（tx），其概率为2 / m。 因此，这种q项共享相同两个桶的概率是<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mi mathvariant="normal">/</mi><mi>m</mi><mo separator="true">⋅</mo><mn>1</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mi>f</mi></msup><msup><mo>)</mo><mrow><mi>q</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(2/m · 1/2^f )^{q−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.09911em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord">/</span><span class="mord mathit">m</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">q</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span> 。<br>
Now consider a construction process that inserts n random items to an empty table of m = cn buckets for a constant c and constant bucket size b. Whenever there are q = 2b + 1 items mapped into the same two buckets, the insertion fails. This probability provides a lower bound for failure (and, we believe, dominates the failure probability of this construction process, although we do not prove this and do not need to in order to obtain a lower bound). Since there are in total <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>⟮</mo><mrow><mn>2</mn><mi>b</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>⟯</mo></mrow><annotation encoding="application/x-tex">\lgroup_{2b+1}^{n}\rgroup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.08544em; vertical-align: -0.341439em;"></span><span class="mopen"><span class="mopen">⟮</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -2.41689em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathit mtight">b</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.341439em;"><span class=""></span></span></span></span></span></span><span class="mclose">⟯</span></span></span></span></span> different possible sets of 2b+1 items out of n items, the expected number of groups of 2b + 1 items colliding during the construction process is 现在考虑一个构造过程，它将n个随机项插入到m = cn桶的空表中，以获得常数c和常量桶大小b。 每当有q = 2b + 1项映射到相同的两个桶时，插入失败。 这种概率提供了失败的下限（并且，我们认为，这主导了这个施工过程的失败概率，尽管我们没有证明这一点，也不需要为了获得下限）。 由于在n个项目中总共有<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>⟮</mo><mrow><mn>2</mn><mi>b</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>⟯</mo></mrow><annotation encoding="application/x-tex">\lgroup_{2b+1}^{n}\rgroup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.08544em; vertical-align: -0.341439em;"></span><span class="mopen"><span class="mopen">⟮</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -2.41689em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathit mtight">b</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.341439em;"><span class=""></span></span></span></span></span></span><span class="mclose">⟯</span></span></span></span></span> 不同的可能的2b + 1个项目集合，因此在构建过程中碰撞的2b + 1个项目的预期组数是<br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>⟮</mo><mrow><mn>2</mn><mi>b</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>⟯</mo><mo>⟮</mo><mfrac><mn>2</mn><mrow><msup><mn>2</mn><mi>f</mi></msup><mi mathvariant="normal">.</mi><mi>m</mi></mrow></mfrac><msup><mo>⟯</mo><mrow><mn>2</mn><mi>b</mi></mrow></msup><mo>=</mo><msubsup><mo>⟮</mo><mrow><mn>2</mn><mi>b</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>⟯</mo><mo>⟮</mo><mfrac><mn>2</mn><mrow><msup><mn>2</mn><mi>f</mi></msup><mi mathvariant="normal">.</mi><mi>c</mi><mi>n</mi></mrow></mfrac><msup><mo>⟯</mo><mrow><mn>2</mn><mi>b</mi></mrow></msup><mo>=</mo><mi mathvariant="normal">Ω</mi><mo>⟮</mo><mfrac><mi>n</mi><mrow><msup><mn>4</mn><mi>b</mi></msup><mi>f</mi></mrow></mfrac><mo>⟯</mo></mrow><annotation encoding="application/x-tex">\lgroup^{n}_{2b+1}\rgroup\lgroup\frac 2{2^f.m}\rgroup^{2b}=\lgroup^{n}_{2b+1}\rgroup\lgroup\frac 2{2^f.cn}\rgroup^{2b} = \Omega\lgroup\frac n{4^bf}\rgroup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.20653em; vertical-align: -0.35742em;"></span><span class="mopen"><span class="mopen">⟮</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -2.41689em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathit mtight">b</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.341439em;"><span class=""></span></span></span></span></span></span><span class="mclose">⟯</span><span class="mopen">⟮</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.845108em;"><span class="" style="top: -2.64258em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.782029em;"><span class="" style="top: -2.786em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span><span class="mord mtight">.</span><span class="mord mathit mtight">m</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.35742em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">⟯</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathit mtight">b</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.20653em; vertical-align: -0.35742em;"></span><span class="mopen"><span class="mopen">⟮</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -2.41689em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathit mtight">b</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.341439em;"><span class=""></span></span></span></span></span></span><span class="mclose">⟯</span><span class="mopen">⟮</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.845108em;"><span class="" style="top: -2.64258em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.782029em;"><span class="" style="top: -2.786em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span></span></span></span></span><span class="mord mtight">.</span><span class="mord mathit mtight">c</span><span class="mord mathit mtight">n</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.35742em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">⟯</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathit mtight">b</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.23753em; vertical-align: -0.493528em;"></span><span class="mord">Ω</span><span class="mopen">⟮</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.64258em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.782029em;"><span class="" style="top: -2.786em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathit mtight">b</span></span></span></span></span></span></span></span><span class="mord mathit mtight" style="margin-right: 0.10764em;">f</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.493528em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⟯</span></span></span></span></span><br>
We conclude that <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>4</mn><mi>b</mi></msup><mi>f</mi></mrow><annotation encoding="application/x-tex">4^bf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">b</span></span></span></span></span></span></span></span><span class="mord mathit" style="margin-right: 0.10764em;">f</span></span></span></span></span> must be <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></span> to avoid a non-trivial probability of failure, as otherwise this expectation is <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>. Therefore, the fingerprint size must be <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f=\Omega(log n/b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">n</span><span class="mord">/</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span></span> bits.我们得出结论，<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>4</mn><mi>b</mi></msup><mi>f</mi></mrow><annotation encoding="application/x-tex">4^bf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1.04355em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">b</span></span></span></span></span></span></span></span><span class="mord mathit" style="margin-right: 0.10764em;">f</span></span></span></span></span>必须是<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></span>以避免非平凡的失败概率，否则这个期望是<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>。 因此，指纹大小必须是<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f=\Omega(log n/b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">n</span><span class="mord">/</span><span class="mord mathit">b</span><span class="mclose">)</span></span></span></span></span> bits。<br>
This result seems somewhat unfortunate, as the number of bits required for the fingerprint is <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></span>; recall that Bloom filters use a constant (approximately <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>n</mi><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ϵ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">ln(1/\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">ϵ</span><span class="mclose">)</span></span></span></span></span>bits) per item. We might therefore have concerns about the scalability of this approach. As we show next, however, practical applications of cuckoo filters are saved by the b factor in the denominator of the lower bound: as long as we use reasonably sized buckets, the fingerprint size can remain small.这个结果似乎有点不幸，因为指纹所需的位数是<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Omega(log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span></span>; 回想一下，Bloom过滤器每个项目使用一个常量（大约<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>n</mi><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ϵ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">ln(1/\epsilon)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathit">ϵ</span><span class="mclose">)</span></span></span></span></span>位）。 因此，我们可能会担心这种方法的可扩展性。 然而，正如我们接下来所示，布谷鸟过滤器的实际应用由b因子保存在下限的分母中：只要我们使用合理大小的桶，指纹大小就可以保持很小。</p>

